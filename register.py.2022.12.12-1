#!/bin/env python3

# Function to determine primary key of table.
def getPrimaryKey(sqlConnection, table):

    import sqlite_interop as si
    import helpers as h

    # Get the id field value for the passed.
    tableInfo = si.fetchData(
          sqlConnection
        , "PRAGMA table_info(" + table + ");"
    )

    # What is the name of the primary key?
    try:
        primaryKey = h.selectDictianory(tableInfo, "pk", 1)["name"]
    except Exception as e:
        print("Could not determine the primary key for table: " + table)
        print(e)
        return 1   # End function with error 1.


    return primaryKey


# Get the id of a dataset identified by
# unique pairs of fields / keys and values.
def getId(sqlConnection, table, stringIdentifiers):

    import sqlite_interop as si

    # Retrieve the column name of the primary key in "table".
    primaryKey = getPrimaryKey(sqlConnection, table)

    # Build where clause:
    wheres = [x + " = \'" + stringIdentifiers[x] + "\'" for x in stringIdentifiers]
    whereClause = " AND ".join(wheres)

    # Find the id of the required dataset in the detail table.
    idDetail = si.fetchData(
        sqlConnection
      , "SELECT " + primaryKey
            + " FROM " + table
            + " WHERE " + whereClause
    )

    if len(idDetail) == 1:
        return idDetail[0][primaryKey]
    else:
        raise ValueError("Expected one result row but got " + str(len(idDetail)))



# Generic insert into database.
def genericInsert(sqlConnection, tableName, fieldList, valueList):

    import sqlite_interop as si

    if len(fieldList) != len(valueList):
        raise ValueError("List of fields and list of values don't have the same length")
        return -1

    # Insert into procedure table.
    try:
        si.executeStatement(
            sqlConnection
          , si.buildQueryString(
                "./sql/GENERIC_INSERT.SQL"
              , {
                    "tableName": tableName
                   , "fieldList": ", ".join(fieldList)
                   , "valueList": "\'" + "\', \'".join(valueList) + "\'"
                }
            )
        )
    except Exception as e:
        print(
            "While trying to perform an import to: "
              + tableName + " and this error occured"
        )
        print(e)
        return -1



# Generic import function.
def genericImportDictionaries(
    sqlConnection
  , dictianories
  , mainTable
  , ignoreFields = None
  , verbose = True
):

    # For contacting the database.
    import sqlite_interop as si
    import helpers as h
    import pprint

    # Get the id field value for the passed.
    primaryKey = getPrimaryKey(sqlConnection, mainTable)

    # Loop over all parsed dictianories. Could be more than one in document.
    for dictianory in dictianories:

        if verbose:
            print("Importing this dataset into " + mainTable)
            pprint.pprint(dictianory)

        # Get the biggest id for the table in question.
        maxId = si.fetchData(
            sqlConnection
          , "SELECT MAX(" + primaryKey + ") FROM `" + mainTable + "`"
        )[0]["MAX(" + primaryKey + ")"] or 0  # TODO: This can't always be 0.

        # Set the new id.
        newId = maxId +1

        # Values that are not another dictianory should be entered into
        # the table directly.
        mainTableFields = [
            k for k in dictianory.keys() if type(dictianory[k]) is not list
        ]
        mainTableValues = [
            str(dictianory[k])
                for k in dictianory.keys() if type(dictianory[k]) is not list
        ]

        # Add the row id.
        mainTableFields.append(primaryKey)
        mainTableValues.append(str(newId))

        # Handle 1-n relations. The easy part.
        try:
            oneNdictianories = [oND for oND in dictianory["n to 1 joins"]]  # TODO: Remove hardcoding.
        except KeyError:
            oneNdictianories = []

        for d in oneNdictianories:

            # The algorithm for 1 to n relations is easy. Just determine
            # the foreign key and enter it into the dataset.
            foreignTable = d["foreign table name"]

            try:
                foreignIdField = d["foreign id field"]
            except KeyError:  # If none os provided, guess id.
                foreignIdField = "id_" + foreignTable

            # Remove identifying fields.
            d.pop("foreign table name")
            try:
                d.pop("foreign id field")
            except KeyError:
                pass

            # Employ the getId function to retrieve fitting foreign id.
            foreignId = getId(sqlConnection, foreignTable, d)

            if verbose:
                print(
                    "For " + foreignTable + " I found the id: " + str(foreignId)
                )

            # Add field and respective value to insert list.
            mainTableFields.append(foreignIdField)
            mainTableValues.append(str(foreignId))


        # When everything is ready import these things into the main table.
        # Call generic insert function.
        if verbose:
            print("Will try to insert the following fields and values.")
            print("Fields: " + "; ".join(mainTableFields))
            print("Values: " + "; ".join(mainTableValues))

        genericInsert(
            sqlConnection
          , mainTable
          , mainTableFields
          , mainTableValues
        )

        # The hard part: connect n to m relations.
        try:
            nmAttach(
                sqlConnection
              , mainTable
              , primaryKey
              , newId
              , [nm for nm in dictianory["n to m joins"]]
              , verbose = True
            )
        except KeyError:
            pass  # No nm relations.



# Attaching nm relations.
def nmAttach(
    sqlConnection
  , mainTable
  , mainTableIdField
  , mainTableId
  , nmDictianories
  , verbose = False
):

    # Loop over all dictianories that describe datasets which
    # should be connected via n to m relations.
    for nm in nmDictianories:

        # Like in 1 to n relations, determine name and id field for
        # the foreign table.
        foreignTable = nm["foreign table name"]

        # It's optional to provide the name of an external id field.
        try:
            foreignIdField = nm["foreign id field"]
        except KeyError:  # If none os provided, guess id.
            foreignIdField = "id_" + foreignTable

        # In which connecting (nm) table should this dataset
        # be imported.
        try:
            nmTable = nm["nm table name"]
        except KeyError:
            nmTable = mainTable + "_" + nm["foreign table name"]

        # Remove identifying fields.
        nm.pop("foreign table name")
        try:
            nm.pop("foreign id field")
            nm.pop("nm table name")
        except KeyError:
            pass


        if verbose: print("Conneting values for: " + foreignTable)

        # Now loop over all the values from the list and determine id.
        for f in nm["foreign table values"]:

            # The harder part: Some relations can contain further information.
            # E.g. samples have distinct numbers in each order and
            # measurands can have different units and precisions depending
            # on which procedure is employed.
            try:
                additionalInfoFields = f["additional information"].keys()
                additionalInfoValues = f["additional information"].values()
                f.pop("additional information")  # Remove this key.
            except KeyError:
                additionalInfoFields = []  # If the key doesn't exist ...
                additionalInfoValues = []  # ... work with an empty list
                pass


            # Hardest part. Determine additional foreign keys like
            # the key for a specific unit of a measurand.
            try:
                additionalFK = f["additional foregin keys"]
                print(additionalFK)
            except KeyError:
                pass

            # Try to get the foreign id.
            print(f)
            try:
                foreignId = getId(
                    sqlConnection
                  , foreignTable
                    # Use only string values for the values of f.
                  , {key: str(val) for key, val in f.items()}
                )
            except Exception as e:
                print(e)

            # Create lists with fields and their respective values.
            fieldList = [mainTableIdField, foreignIdField]+ list(additionalInfoFields)
            valueList = [mainTableId, foreignId] + list(additionalInfoValues)

            # Insert the connection.
            genericInsert(
                sqlConnection
              , nmTable
              , fieldList
              , [str(v) for v in valueList]
            )
